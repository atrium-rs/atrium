// @generated - This file is generated by atrium-codegen. DO NOT EDIT.
//!Definitions for the `app.bsky.unspecced.getPostThreadV2` namespace.
pub const NSID: &str = "app.bsky.unspecced.getPostThreadV2";
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ParametersData {
    ///Whether to include parents above the anchor.
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub above: core::option::Option<bool>,
    ///Reference (AT-URI) to post record. This is the anchor post, and the thread will be built around it. It can be any post in the tree, not necessarily a root post.
    pub anchor: String,
    ///How many levels of replies to include below the anchor.
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub below: core::option::Option<crate::types::LimitedU8<20u8>>,
    ///Maximum of replies to include at each level of the thread, except for the direct replies to the anchor, which are (NOTE: currently, during unspecced phase) all returned (NOTE: later they might be paginated).
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub branching_factor: core::option::Option<crate::types::LimitedU8<100u8>>,
    ///Whether to prioritize posts from followed users. It only has effect when the user is authenticated.
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub prioritize_followed_users: core::option::Option<bool>,
    ///Sorting for the thread replies.
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub sort: core::option::Option<String>,
}
pub type Parameters = crate::types::Object<ParametersData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct OutputData {
    ///Whether this thread has additional replies. If true, a call can be made to the `getPostThreadOtherV2` endpoint to retrieve them.
    pub has_other_replies: bool,
    ///A flat list of thread items. The depth of each item is indicated by the depth property inside the item.
    pub thread: Vec<ThreadItem>,
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub threadgate: core::option::Option<crate::app::bsky::feed::defs::ThreadgateView>,
}
pub type Output = crate::types::Object<OutputData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "error", content = "message")]
pub enum Error {}
impl std::fmt::Display for Error {
    fn fmt(&self, _f: &mut std::fmt::Formatter) -> std::fmt::Result {
        Ok(())
    }
}
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ThreadItemData {
    ///The nesting level of this item in the thread. Depth 0 means the anchor item. Items above have negative depths, items below have positive depths.
    pub depth: i64,
    pub uri: String,
    pub value: crate::types::Union<ThreadItemValueRefs>,
}
pub type ThreadItem = crate::types::Object<ThreadItemData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "$type")]
pub enum ThreadItemValueRefs {
    #[serde(rename = "app.bsky.unspecced.defs#threadItemPost")]
    AppBskyUnspeccedDefsThreadItemPost(Box<crate::app::bsky::unspecced::defs::ThreadItemPost>),
    #[serde(rename = "app.bsky.unspecced.defs#threadItemNoUnauthenticated")]
    AppBskyUnspeccedDefsThreadItemNoUnauthenticated(
        Box<crate::app::bsky::unspecced::defs::ThreadItemNoUnauthenticated>,
    ),
    #[serde(rename = "app.bsky.unspecced.defs#threadItemNotFound")]
    AppBskyUnspeccedDefsThreadItemNotFound(
        Box<crate::app::bsky::unspecced::defs::ThreadItemNotFound>,
    ),
    #[serde(rename = "app.bsky.unspecced.defs#threadItemBlocked")]
    AppBskyUnspeccedDefsThreadItemBlocked(
        Box<crate::app::bsky::unspecced::defs::ThreadItemBlocked>,
    ),
}
