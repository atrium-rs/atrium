// This file is generated by atrium-codegen. DO NOT EDIT.
//!Structs for ATP client, implements all HTTP APIs of XRPC.
///Client struct for the ATP service.
pub struct AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub service: Service<T>,
}
impl<T> AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub fn new(xrpc: T) -> Self {
        Self {
            service: Service::new(std::sync::Arc::new(xrpc)),
        }
    }
}
pub struct Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub app: app::Service<T>,
    pub com: com::Service<T>,
}
pub mod app {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        pub bsky: bsky::Service<T>,
    }
    pub mod bsky {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub actor: actor::Service<T>,
            pub feed: feed::Service<T>,
            pub graph: graph::Service<T>,
            pub notification: notification::Service<T>,
            pub unspecced: unspecced::Service<T>,
        }
        pub mod actor {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod feed {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod graph {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod notification {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod unspecced {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
    }
}
pub mod com {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        pub atproto: atproto::Service<T>,
    }
    pub mod atproto {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub admin: admin::Service<T>,
            pub identity: identity::Service<T>,
            pub label: label::Service<T>,
            pub moderation: moderation::Service<T>,
            pub repo: repo::Service<T>,
            pub server: server::Service<T>,
            pub sync: sync::Service<T>,
            pub temp: temp::Service<T>,
        }
        pub mod admin {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod identity {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod label {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod moderation {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod repo {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod server {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod sync {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod temp {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
    }
}
impl<T> self::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            app: app::Service::new(std::sync::Arc::clone(&xrpc)),
            com: com::Service::new(std::sync::Arc::clone(&xrpc)),
        }
    }
}
impl<T> app::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            bsky: app::bsky::Service::new(std::sync::Arc::clone(&xrpc)),
        }
    }
}
impl<T> app::bsky::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            actor: app::bsky::actor::Service::new(std::sync::Arc::clone(&xrpc)),
            feed: app::bsky::feed::Service::new(std::sync::Arc::clone(&xrpc)),
            graph: app::bsky::graph::Service::new(std::sync::Arc::clone(&xrpc)),
            notification: app::bsky::notification::Service::new(
                std::sync::Arc::clone(&xrpc),
            ),
            unspecced: app::bsky::unspecced::Service::new(std::sync::Arc::clone(&xrpc)),
        }
    }
}
impl<T> app::bsky::actor::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth.
    pub async fn get_preferences(
        &self,
        params: crate::app::bsky::actor::get_preferences::Parameters,
    ) -> Result<
        crate::app::bsky::actor::get_preferences::Output,
        atrium_xrpc::error::Error<crate::app::bsky::actor::get_preferences::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.getPreferences".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth.
    pub async fn get_profile(
        &self,
        params: crate::app::bsky::actor::get_profile::Parameters,
    ) -> Result<
        crate::app::bsky::actor::get_profile::Output,
        atrium_xrpc::error::Error<crate::app::bsky::actor::get_profile::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.getProfile".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get detailed profile views of multiple actors.
    pub async fn get_profiles(
        &self,
        params: crate::app::bsky::actor::get_profiles::Parameters,
    ) -> Result<
        crate::app::bsky::actor::get_profiles::Output,
        atrium_xrpc::error::Error<crate::app::bsky::actor::get_profiles::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.getProfiles".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding.
    pub async fn get_suggestions(
        &self,
        params: crate::app::bsky::actor::get_suggestions::Parameters,
    ) -> Result<
        crate::app::bsky::actor::get_suggestions::Output,
        atrium_xrpc::error::Error<crate::app::bsky::actor::get_suggestions::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.getSuggestions".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Set the private preferences attached to the account.
    pub async fn put_preferences(
        &self,
        input: crate::app::bsky::actor::put_preferences::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::actor::put_preferences::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.actor.putPreferences".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Find actors (profiles) matching search criteria. Does not require auth.
    pub async fn search_actors(
        &self,
        params: crate::app::bsky::actor::search_actors::Parameters,
    ) -> Result<
        crate::app::bsky::actor::search_actors::Output,
        atrium_xrpc::error::Error<crate::app::bsky::actor::search_actors::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.searchActors".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth.
    pub async fn search_actors_typeahead(
        &self,
        params: crate::app::bsky::actor::search_actors_typeahead::Parameters,
    ) -> Result<
        crate::app::bsky::actor::search_actors_typeahead::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::actor::search_actors_typeahead::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.searchActorsTypeahead".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::feed::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View).
    pub async fn describe_feed_generator(
        &self,
    ) -> Result<
        crate::app::bsky::feed::describe_feed_generator::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::describe_feed_generator::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.describeFeedGenerator".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of feeds (feed generator records) created by the actor (in the actor's repo).
    pub async fn get_actor_feeds(
        &self,
        params: crate::app::bsky::feed::get_actor_feeds::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_actor_feeds::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_actor_feeds::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getActorFeeds".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of posts liked by an actor. Does not require auth.
    pub async fn get_actor_likes(
        &self,
        params: crate::app::bsky::feed::get_actor_likes::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_actor_likes::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_actor_likes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getActorLikes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth.
    pub async fn get_author_feed(
        &self,
        params: crate::app::bsky::feed::get_author_feed::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_author_feed::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_author_feed::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getAuthorFeed".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a hydrated feed from an actor's selected feed generator. Implemented by App View.
    pub async fn get_feed(
        &self,
        params: crate::app::bsky::feed::get_feed::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_feed::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_feed::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getFeed".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get information about a feed generator. Implemented by AppView.
    pub async fn get_feed_generator(
        &self,
        params: crate::app::bsky::feed::get_feed_generator::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_feed_generator::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_feed_generator::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getFeedGenerator".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get information about a list of feed generators.
    pub async fn get_feed_generators(
        &self,
        params: crate::app::bsky::feed::get_feed_generators::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_feed_generators::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_feed_generators::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getFeedGenerators".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service.
    pub async fn get_feed_skeleton(
        &self,
        params: crate::app::bsky::feed::get_feed_skeleton::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_feed_skeleton::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_feed_skeleton::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getFeedSkeleton".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get like records which reference a subject (by AT-URI and CID).
    pub async fn get_likes(
        &self,
        params: crate::app::bsky::feed::get_likes::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_likes::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_likes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getLikes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth.
    pub async fn get_list_feed(
        &self,
        params: crate::app::bsky::feed::get_list_feed::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_list_feed::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_list_feed::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getListFeed".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests.
    pub async fn get_post_thread(
        &self,
        params: crate::app::bsky::feed::get_post_thread::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_post_thread::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_post_thread::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getPostThread".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'.
    pub async fn get_posts(
        &self,
        params: crate::app::bsky::feed::get_posts::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_posts::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_posts::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getPosts".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of reposts for a given post.
    pub async fn get_reposted_by(
        &self,
        params: crate::app::bsky::feed::get_reposted_by::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_reposted_by::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_reposted_by::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getRepostedBy".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of suggested feeds (feed generators) for the requesting account.
    pub async fn get_suggested_feeds(
        &self,
        params: crate::app::bsky::feed::get_suggested_feeds::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_suggested_feeds::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_suggested_feeds::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getSuggestedFeeds".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed.
    pub async fn get_timeline(
        &self,
        params: crate::app::bsky::feed::get_timeline::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_timeline::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_timeline::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getTimeline".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Find posts matching search criteria, returning views of those posts.
    pub async fn search_posts(
        &self,
        params: crate::app::bsky::feed::search_posts::Parameters,
    ) -> Result<
        crate::app::bsky::feed::search_posts::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::search_posts::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.searchPosts".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::graph::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Enumerates which accounts the requesting account is currently blocking. Requires auth.
    pub async fn get_blocks(
        &self,
        params: crate::app::bsky::graph::get_blocks::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_blocks::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_blocks::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getBlocks".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates accounts which follow a specified account (actor).
    pub async fn get_followers(
        &self,
        params: crate::app::bsky::graph::get_followers::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_followers::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_followers::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getFollowers".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates accounts which a specified account (actor) follows.
    pub async fn get_follows(
        &self,
        params: crate::app::bsky::graph::get_follows::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_follows::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_follows::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getFollows".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Gets a 'view' (with additional context) of a specified list.
    pub async fn get_list(
        &self,
        params: crate::app::bsky::graph::get_list::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_list::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_list::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getList".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get mod lists that the requesting account (actor) is blocking. Requires auth.
    pub async fn get_list_blocks(
        &self,
        params: crate::app::bsky::graph::get_list_blocks::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_list_blocks::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_list_blocks::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getListBlocks".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth.
    pub async fn get_list_mutes(
        &self,
        params: crate::app::bsky::graph::get_list_mutes::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_list_mutes::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_list_mutes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getListMutes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates the lists created by a specified account (actor).
    pub async fn get_lists(
        &self,
        params: crate::app::bsky::graph::get_lists::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_lists::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_lists::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getLists".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates accounts that the requesting account (actor) currently has muted. Requires auth.
    pub async fn get_mutes(
        &self,
        params: crate::app::bsky::graph::get_mutes::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_mutes::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_mutes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getMutes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates public relationships between one account, and a list of other accounts. Does not require auth.
    pub async fn get_relationships(
        &self,
        params: crate::app::bsky::graph::get_relationships::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_relationships::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_relationships::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getRelationships".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account.
    pub async fn get_suggested_follows_by_actor(
        &self,
        params: crate::app::bsky::graph::get_suggested_follows_by_actor::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_suggested_follows_by_actor::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::graph::get_suggested_follows_by_actor::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getSuggestedFollowsByActor".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth.
    pub async fn mute_actor(
        &self,
        input: crate::app::bsky::graph::mute_actor::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::graph::mute_actor::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.graph.muteActor".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth.
    pub async fn mute_actor_list(
        &self,
        input: crate::app::bsky::graph::mute_actor_list::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::graph::mute_actor_list::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.graph.muteActorList".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Unmutes the specified account. Requires auth.
    pub async fn unmute_actor(
        &self,
        input: crate::app::bsky::graph::unmute_actor::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::graph::unmute_actor::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.graph.unmuteActor".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Unmutes the specified list of accounts. Requires auth.
    pub async fn unmute_actor_list(
        &self,
        input: crate::app::bsky::graph::unmute_actor_list::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::graph::unmute_actor_list::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.graph.unmuteActorList".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::notification::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Count the number of unread notifications for the requesting account. Requires auth.
    pub async fn get_unread_count(
        &self,
        params: crate::app::bsky::notification::get_unread_count::Parameters,
    ) -> Result<
        crate::app::bsky::notification::get_unread_count::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::notification::get_unread_count::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.notification.getUnreadCount".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Enumerate notifications for the requesting account. Requires auth.
    pub async fn list_notifications(
        &self,
        params: crate::app::bsky::notification::list_notifications::Parameters,
    ) -> Result<
        crate::app::bsky::notification::list_notifications::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::notification::list_notifications::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.notification.listNotifications".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Register to receive push notifications, via a specified service, for the requesting account. Requires auth.
    pub async fn register_push(
        &self,
        input: crate::app::bsky::notification::register_push::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::notification::register_push::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.notification.registerPush".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Notify server that the requesting account has seen notifications. Requires auth.
    pub async fn update_seen(
        &self,
        input: crate::app::bsky::notification::update_seen::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::notification::update_seen::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.notification.updateSeen".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::unspecced::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///An unspecced view of globally popular feed generators.
    pub async fn get_popular_feed_generators(
        &self,
        params: crate::app::bsky::unspecced::get_popular_feed_generators::Parameters,
    ) -> Result<
        crate::app::bsky::unspecced::get_popular_feed_generators::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::unspecced::get_popular_feed_generators::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.unspecced.getPopularFeedGenerators".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of suggestions (feeds and users) tagged with categories
    pub async fn get_tagged_suggestions(
        &self,
        params: crate::app::bsky::unspecced::get_tagged_suggestions::Parameters,
    ) -> Result<
        crate::app::bsky::unspecced::get_tagged_suggestions::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::unspecced::get_tagged_suggestions::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.unspecced.getTaggedSuggestions".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Backend Actors (profile) search, returns only skeleton.
    pub async fn search_actors_skeleton(
        &self,
        params: crate::app::bsky::unspecced::search_actors_skeleton::Parameters,
    ) -> Result<
        crate::app::bsky::unspecced::search_actors_skeleton::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::unspecced::search_actors_skeleton::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.unspecced.searchActorsSkeleton".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Backend Posts search, returns only skeleton
    pub async fn search_posts_skeleton(
        &self,
        params: crate::app::bsky::unspecced::search_posts_skeleton::Parameters,
    ) -> Result<
        crate::app::bsky::unspecced::search_posts_skeleton::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::unspecced::search_posts_skeleton::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.unspecced.searchPostsSkeleton".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            atproto: com::atproto::Service::new(std::sync::Arc::clone(&xrpc)),
        }
    }
}
impl<T> com::atproto::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            admin: com::atproto::admin::Service::new(std::sync::Arc::clone(&xrpc)),
            identity: com::atproto::identity::Service::new(std::sync::Arc::clone(&xrpc)),
            label: com::atproto::label::Service::new(std::sync::Arc::clone(&xrpc)),
            moderation: com::atproto::moderation::Service::new(
                std::sync::Arc::clone(&xrpc),
            ),
            repo: com::atproto::repo::Service::new(std::sync::Arc::clone(&xrpc)),
            server: com::atproto::server::Service::new(std::sync::Arc::clone(&xrpc)),
            sync: com::atproto::sync::Service::new(std::sync::Arc::clone(&xrpc)),
            temp: com::atproto::temp::Service::new(std::sync::Arc::clone(&xrpc)),
        }
    }
}
impl<T> com::atproto::admin::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Administrative action to create a new, re-usable communication (email for now) template.
    pub async fn create_communication_template(
        &self,
        input: crate::com::atproto::admin::create_communication_template::Input,
    ) -> Result<
        crate::com::atproto::admin::create_communication_template::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::create_communication_template::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.createCommunicationTemplate".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Delete a user account as an administrator.
    pub async fn delete_account(
        &self,
        input: crate::com::atproto::admin::delete_account::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::admin::delete_account::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.deleteAccount".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Delete a communication template.
    pub async fn delete_communication_template(
        &self,
        input: crate::com::atproto::admin::delete_communication_template::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::delete_communication_template::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.deleteCommunicationTemplate".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Disable an account from receiving new invite codes, but does not invalidate existing codes.
    pub async fn disable_account_invites(
        &self,
        input: crate::com::atproto::admin::disable_account_invites::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::disable_account_invites::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.disableAccountInvites".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Disable some set of codes and/or all codes associated with a set of users.
    pub async fn disable_invite_codes(
        &self,
        input: crate::com::atproto::admin::disable_invite_codes::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::disable_invite_codes::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.disableInviteCodes".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Take a moderation action on an actor.
    pub async fn emit_moderation_event(
        &self,
        input: crate::com::atproto::admin::emit_moderation_event::Input,
    ) -> Result<
        crate::com::atproto::admin::emit_moderation_event::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::emit_moderation_event::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.emitModerationEvent".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Re-enable an account's ability to receive invite codes.
    pub async fn enable_account_invites(
        &self,
        input: crate::com::atproto::admin::enable_account_invites::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::enable_account_invites::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.enableAccountInvites".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get details about an account.
    pub async fn get_account_info(
        &self,
        params: crate::com::atproto::admin::get_account_info::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_account_info::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::get_account_info::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getAccountInfo".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get details about some accounts.
    pub async fn get_account_infos(
        &self,
        params: crate::com::atproto::admin::get_account_infos::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_account_infos::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::get_account_infos::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getAccountInfos".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get an admin view of invite codes.
    pub async fn get_invite_codes(
        &self,
        params: crate::com::atproto::admin::get_invite_codes::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_invite_codes::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::get_invite_codes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getInviteCodes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get details about a moderation event.
    pub async fn get_moderation_event(
        &self,
        params: crate::com::atproto::admin::get_moderation_event::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_moderation_event::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::get_moderation_event::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getModerationEvent".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get details about a record.
    pub async fn get_record(
        &self,
        params: crate::com::atproto::admin::get_record::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_record::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::get_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getRecord".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get details about a repository.
    pub async fn get_repo(
        &self,
        params: crate::com::atproto::admin::get_repo::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_repo::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::get_repo::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getRepo".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get the service-specific admin status of a subject (account, record, or blob).
    pub async fn get_subject_status(
        &self,
        params: crate::com::atproto::admin::get_subject_status::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_subject_status::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::get_subject_status::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getSubjectStatus".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get list of all communication templates.
    pub async fn list_communication_templates(
        &self,
    ) -> Result<
        crate::com::atproto::admin::list_communication_templates::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::list_communication_templates::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.listCommunicationTemplates".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///List moderation events related to a subject.
    pub async fn query_moderation_events(
        &self,
        params: crate::com::atproto::admin::query_moderation_events::Parameters,
    ) -> Result<
        crate::com::atproto::admin::query_moderation_events::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::query_moderation_events::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.queryModerationEvents".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///View moderation statuses of subjects (record or repo).
    pub async fn query_moderation_statuses(
        &self,
        params: crate::com::atproto::admin::query_moderation_statuses::Parameters,
    ) -> Result<
        crate::com::atproto::admin::query_moderation_statuses::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::query_moderation_statuses::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.queryModerationStatuses".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Find repositories based on a search term.
    pub async fn search_repos(
        &self,
        params: crate::com::atproto::admin::search_repos::Parameters,
    ) -> Result<
        crate::com::atproto::admin::search_repos::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::search_repos::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.searchRepos".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Send email to a user's account email address.
    pub async fn send_email(
        &self,
        input: crate::com::atproto::admin::send_email::Input,
    ) -> Result<
        crate::com::atproto::admin::send_email::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::send_email::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.sendEmail".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Administrative action to update an account's email.
    pub async fn update_account_email(
        &self,
        input: crate::com::atproto::admin::update_account_email::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::update_account_email::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.updateAccountEmail".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Administrative action to update an account's handle.
    pub async fn update_account_handle(
        &self,
        input: crate::com::atproto::admin::update_account_handle::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::update_account_handle::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.updateAccountHandle".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Update the password for a user account as an administrator.
    pub async fn update_account_password(
        &self,
        input: crate::com::atproto::admin::update_account_password::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::update_account_password::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.updateAccountPassword".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only.
    pub async fn update_communication_template(
        &self,
        input: crate::com::atproto::admin::update_communication_template::Input,
    ) -> Result<
        crate::com::atproto::admin::update_communication_template::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::update_communication_template::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.updateCommunicationTemplate".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Update the service-specific admin status of a subject (account, record, or blob).
    pub async fn update_subject_status(
        &self,
        input: crate::com::atproto::admin::update_subject_status::Input,
    ) -> Result<
        crate::com::atproto::admin::update_subject_status::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::update_subject_status::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.updateSubjectStatus".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::identity::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Describe the credentials that should be included in the DID doc of an account that is migrating to this service.
    pub async fn get_recommended_did_credentials(
        &self,
    ) -> Result<
        crate::com::atproto::identity::get_recommended_did_credentials::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::identity::get_recommended_did_credentials::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.identity.getRecommendedDidCredentials".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Request an email with a code to in order to request a signed PLC operation. Requires Auth.
    pub async fn request_plc_operation_signature(
        &self,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::identity::request_plc_operation_signature::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.identity.requestPlcOperationSignature".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Resolves a handle (domain name) to a DID.
    pub async fn resolve_handle(
        &self,
        params: crate::com::atproto::identity::resolve_handle::Parameters,
    ) -> Result<
        crate::com::atproto::identity::resolve_handle::Output,
        atrium_xrpc::error::Error<crate::com::atproto::identity::resolve_handle::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.identity.resolveHandle".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Signs a PLC operation to update some value(s) in the requesting DID's document.
    pub async fn sign_plc_operation(
        &self,
        input: crate::com::atproto::identity::sign_plc_operation::Input,
    ) -> Result<
        crate::com::atproto::identity::sign_plc_operation::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::identity::sign_plc_operation::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.identity.signPlcOperation".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry
    pub async fn submit_plc_operation(
        &self,
        input: crate::com::atproto::identity::submit_plc_operation::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::identity::submit_plc_operation::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.identity.submitPlcOperation".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth.
    pub async fn update_handle(
        &self,
        input: crate::com::atproto::identity::update_handle::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::identity::update_handle::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.identity.updateHandle".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::label::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth.
    pub async fn query_labels(
        &self,
        params: crate::com::atproto::label::query_labels::Parameters,
    ) -> Result<
        crate::com::atproto::label::query_labels::Output,
        atrium_xrpc::error::Error<crate::com::atproto::label::query_labels::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.label.queryLabels".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::moderation::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth.
    pub async fn create_report(
        &self,
        input: crate::com::atproto::moderation::create_report::Input,
    ) -> Result<
        crate::com::atproto::moderation::create_report::Output,
        atrium_xrpc::error::Error<crate::com::atproto::moderation::create_report::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.moderation.createReport".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::repo::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS.
    pub async fn apply_writes(
        &self,
        input: crate::com::atproto::repo::apply_writes::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::repo::apply_writes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.repo.applyWrites".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create a single new repository record. Requires auth, implemented by PDS.
    pub async fn create_record(
        &self,
        input: crate::com::atproto::repo::create_record::Input,
    ) -> Result<
        crate::com::atproto::repo::create_record::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::create_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.repo.createRecord".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS.
    pub async fn delete_record(
        &self,
        input: crate::com::atproto::repo::delete_record::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::repo::delete_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.repo.deleteRecord".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get information about an account and repository, including the list of collections. Does not require auth.
    pub async fn describe_repo(
        &self,
        params: crate::com::atproto::repo::describe_repo::Parameters,
    ) -> Result<
        crate::com::atproto::repo::describe_repo::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::describe_repo::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.repo.describeRepo".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a single record from a repository. Does not require auth.
    pub async fn get_record(
        &self,
        params: crate::com::atproto::repo::get_record::Parameters,
    ) -> Result<
        crate::com::atproto::repo::get_record::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::get_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.repo.getRecord".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set.
    pub async fn import_repo(
        &self,
        input: Vec<u8>,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::repo::import_repo::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                Vec<u8>,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.repo.importRepo".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Bytes(input)),
                    encoding: Some(String::from("application/vnd.ipld.car")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow.
    pub async fn list_missing_blobs(
        &self,
        params: crate::com::atproto::repo::list_missing_blobs::Parameters,
    ) -> Result<
        crate::com::atproto::repo::list_missing_blobs::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::list_missing_blobs::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.repo.listMissingBlobs".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///List a range of records in a repository, matching a specific collection. Does not require auth.
    pub async fn list_records(
        &self,
        params: crate::com::atproto::repo::list_records::Parameters,
    ) -> Result<
        crate::com::atproto::repo::list_records::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::list_records::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.repo.listRecords".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS.
    pub async fn put_record(
        &self,
        input: crate::com::atproto::repo::put_record::Input,
    ) -> Result<
        crate::com::atproto::repo::put_record::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::put_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.repo.putRecord".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS.
    pub async fn upload_blob(
        &self,
        input: Vec<u8>,
    ) -> Result<
        crate::com::atproto::repo::upload_blob::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::upload_blob::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                Vec<u8>,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.repo.uploadBlob".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Bytes(input)),
                    encoding: Some(String::from("*/*")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::server::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup.
    pub async fn activate_account(
        &self,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::activate_account::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.activateAccount".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself.
    pub async fn check_account_status(
        &self,
    ) -> Result<
        crate::com::atproto::server::check_account_status::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::server::check_account_status::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.server.checkAccountStatus".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Confirm an email using a token from com.atproto.server.requestEmailConfirmation.
    pub async fn confirm_email(
        &self,
        input: crate::com::atproto::server::confirm_email::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::confirm_email::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.confirmEmail".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create an account. Implemented by PDS.
    pub async fn create_account(
        &self,
        input: crate::com::atproto::server::create_account::Input,
    ) -> Result<
        crate::com::atproto::server::create_account::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::create_account::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.createAccount".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create an App Password.
    pub async fn create_app_password(
        &self,
        input: crate::com::atproto::server::create_app_password::Input,
    ) -> Result<
        crate::com::atproto::server::create_app_password::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::server::create_app_password::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.createAppPassword".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create an invite code.
    pub async fn create_invite_code(
        &self,
        input: crate::com::atproto::server::create_invite_code::Input,
    ) -> Result<
        crate::com::atproto::server::create_invite_code::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::create_invite_code::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.createInviteCode".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create invite codes.
    pub async fn create_invite_codes(
        &self,
        input: crate::com::atproto::server::create_invite_codes::Input,
    ) -> Result<
        crate::com::atproto::server::create_invite_codes::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::server::create_invite_codes::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.createInviteCodes".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create an authentication session.
    pub async fn create_session(
        &self,
        input: crate::com::atproto::server::create_session::Input,
    ) -> Result<
        crate::com::atproto::server::create_session::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::create_session::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.createSession".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host.
    pub async fn deactivate_account(
        &self,
        input: crate::com::atproto::server::deactivate_account::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::deactivate_account::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.deactivateAccount".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth.
    pub async fn delete_account(
        &self,
        input: crate::com::atproto::server::delete_account::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::delete_account::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.deleteAccount".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Delete the current session. Requires auth.
    pub async fn delete_session(
        &self,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::delete_session::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.deleteSession".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Describes the server's account creation requirements and capabilities. Implemented by PDS.
    pub async fn describe_server(
        &self,
    ) -> Result<
        crate::com::atproto::server::describe_server::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::describe_server::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.server.describeServer".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get all invite codes for the current account. Requires auth.
    pub async fn get_account_invite_codes(
        &self,
        params: crate::com::atproto::server::get_account_invite_codes::Parameters,
    ) -> Result<
        crate::com::atproto::server::get_account_invite_codes::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::server::get_account_invite_codes::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.server.getAccountInviteCodes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a signed token on behalf of the requesting DID for the requested service.
    pub async fn get_service_auth(
        &self,
        params: crate::com::atproto::server::get_service_auth::Parameters,
    ) -> Result<
        crate::com::atproto::server::get_service_auth::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::get_service_auth::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.server.getServiceAuth".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get information about the current auth session. Requires auth.
    pub async fn get_session(
        &self,
    ) -> Result<
        crate::com::atproto::server::get_session::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::get_session::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.server.getSession".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///List all App Passwords.
    pub async fn list_app_passwords(
        &self,
    ) -> Result<
        crate::com::atproto::server::list_app_passwords::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::list_app_passwords::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.server.listAppPasswords".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt').
    pub async fn refresh_session(
        &self,
    ) -> Result<
        crate::com::atproto::server::refresh_session::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::refresh_session::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.refreshSession".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Initiate a user account deletion via email.
    pub async fn request_account_delete(
        &self,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::server::request_account_delete::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.requestAccountDelete".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Request an email with a code to confirm ownership of email.
    pub async fn request_email_confirmation(
        &self,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::server::request_email_confirmation::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.requestEmailConfirmation".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Request a token in order to update email.
    pub async fn request_email_update(
        &self,
    ) -> Result<
        crate::com::atproto::server::request_email_update::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::server::request_email_update::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.requestEmailUpdate".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Initiate a user account password reset via email.
    pub async fn request_password_reset(
        &self,
        input: crate::com::atproto::server::request_password_reset::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::server::request_password_reset::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.requestPasswordReset".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented.
    pub async fn reserve_signing_key(
        &self,
        input: crate::com::atproto::server::reserve_signing_key::Input,
    ) -> Result<
        crate::com::atproto::server::reserve_signing_key::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::server::reserve_signing_key::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.reserveSigningKey".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Reset a user account password using a token.
    pub async fn reset_password(
        &self,
        input: crate::com::atproto::server::reset_password::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::reset_password::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.resetPassword".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Revoke an App Password by name.
    pub async fn revoke_app_password(
        &self,
        input: crate::com::atproto::server::revoke_app_password::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::server::revoke_app_password::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.revokeAppPassword".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Update an account's email.
    pub async fn update_email(
        &self,
        input: crate::com::atproto::server::update_email::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::update_email::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.updateEmail".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::sync::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS.
    pub async fn get_blob(
        &self,
        params: crate::com::atproto::sync::get_blob::Parameters,
    ) -> Result<
        Vec<u8>,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_blob::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getBlob".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS.
    pub async fn get_blocks(
        &self,
        params: crate::com::atproto::sync::get_blocks::Parameters,
    ) -> Result<
        Vec<u8>,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_blocks::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getBlocks".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///DEPRECATED - please use com.atproto.sync.getRepo instead
    pub async fn get_checkout(
        &self,
        params: crate::com::atproto::sync::get_checkout::Parameters,
    ) -> Result<
        Vec<u8>,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_checkout::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getCheckout".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///DEPRECATED - please use com.atproto.sync.getLatestCommit instead
    pub async fn get_head(
        &self,
        params: crate::com::atproto::sync::get_head::Parameters,
    ) -> Result<
        crate::com::atproto::sync::get_head::Output,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_head::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getHead".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get the current commit CID & revision of the specified repo. Does not require auth.
    pub async fn get_latest_commit(
        &self,
        params: crate::com::atproto::sync::get_latest_commit::Parameters,
    ) -> Result<
        crate::com::atproto::sync::get_latest_commit::Output,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_latest_commit::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getLatestCommit".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth.
    pub async fn get_record(
        &self,
        params: crate::com::atproto::sync::get_record::Parameters,
    ) -> Result<
        Vec<u8>,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getRecord".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS.
    pub async fn get_repo(
        &self,
        params: crate::com::atproto::sync::get_repo::Parameters,
    ) -> Result<
        Vec<u8>,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_repo::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getRepo".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///List blob CIDso for an account, since some repo revision. Does not require auth; implemented by PDS.
    pub async fn list_blobs(
        &self,
        params: crate::com::atproto::sync::list_blobs::Parameters,
    ) -> Result<
        crate::com::atproto::sync::list_blobs::Output,
        atrium_xrpc::error::Error<crate::com::atproto::sync::list_blobs::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.listBlobs".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay.
    pub async fn list_repos(
        &self,
        params: crate::com::atproto::sync::list_repos::Parameters,
    ) -> Result<
        crate::com::atproto::sync::list_repos::Output,
        atrium_xrpc::error::Error<crate::com::atproto::sync::list_repos::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.listRepos".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay.
    pub async fn notify_of_update(
        &self,
        input: crate::com::atproto::sync::notify_of_update::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::sync::notify_of_update::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.sync.notifyOfUpdate".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth.
    pub async fn request_crawl(
        &self,
        input: crate::com::atproto::sync::request_crawl::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::sync::request_crawl::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.sync.requestCrawl".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::temp::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Check accounts location in signup queue.
    pub async fn check_signup_queue(
        &self,
    ) -> Result<
        crate::com::atproto::temp::check_signup_queue::Output,
        atrium_xrpc::error::Error<crate::com::atproto::temp::check_signup_queue::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.temp.checkSignupQueue".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.
    pub async fn fetch_labels(
        &self,
        params: crate::com::atproto::temp::fetch_labels::Parameters,
    ) -> Result<
        crate::com::atproto::temp::fetch_labels::Output,
        atrium_xrpc::error::Error<crate::com::atproto::temp::fetch_labels::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.temp.fetchLabels".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Request a verification code to be sent to the supplied phone number
    pub async fn request_phone_verification(
        &self,
        input: crate::com::atproto::temp::request_phone_verification::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::temp::request_phone_verification::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.temp.requestPhoneVerification".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
