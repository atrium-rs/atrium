// This file is generated by atrium-codegen. DO NOT EDIT.
//!Structs for ATP client, implements all HTTP APIs of XRPC.
///Client struct for the ATP service.
pub struct AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub service: Service<T>,
}
impl<T> AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub fn new(xrpc: T) -> Self {
        Self {
            service: Service::new(std::sync::Arc::new(xrpc)),
        }
    }
}
pub struct Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub app: app::Service<T>,
    pub com: com::Service<T>,
}
pub mod app {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        pub bsky: bsky::Service<T>,
    }
    pub mod bsky {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub actor: actor::Service<T>,
            pub feed: feed::Service<T>,
            pub graph: graph::Service<T>,
            pub notification: notification::Service<T>,
            pub unspecced: unspecced::Service<T>,
        }
        pub mod actor {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod feed {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod graph {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod notification {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod unspecced {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
    }
}
pub mod com {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        pub atproto: atproto::Service<T>,
    }
    pub mod atproto {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub admin: admin::Service<T>,
            pub identity: identity::Service<T>,
            pub label: label::Service<T>,
            pub moderation: moderation::Service<T>,
            pub repo: repo::Service<T>,
            pub server: server::Service<T>,
            pub sync: sync::Service<T>,
            pub temp: temp::Service<T>,
        }
        pub mod admin {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod identity {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod label {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod moderation {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod repo {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod server {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod sync {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
        pub mod temp {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
            }
        }
    }
}
impl<T> self::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            app: app::Service::new(std::sync::Arc::clone(&xrpc)),
            com: com::Service::new(std::sync::Arc::clone(&xrpc)),
        }
    }
}
impl<T> app::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            bsky: app::bsky::Service::new(std::sync::Arc::clone(&xrpc)),
        }
    }
}
impl<T> app::bsky::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            actor: app::bsky::actor::Service::new(std::sync::Arc::clone(&xrpc)),
            feed: app::bsky::feed::Service::new(std::sync::Arc::clone(&xrpc)),
            graph: app::bsky::graph::Service::new(std::sync::Arc::clone(&xrpc)),
            notification: app::bsky::notification::Service::new(
                std::sync::Arc::clone(&xrpc),
            ),
            unspecced: app::bsky::unspecced::Service::new(std::sync::Arc::clone(&xrpc)),
        }
    }
}
impl<T> app::bsky::actor::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Get private preferences attached to the account.
    pub async fn get_preferences(
        &self,
        params: crate::app::bsky::actor::get_preferences::Parameters,
    ) -> Result<
        crate::app::bsky::actor::get_preferences::Output,
        atrium_xrpc::error::Error<crate::app::bsky::actor::get_preferences::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.getPreferences".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get detailed profile view of an actor.
    pub async fn get_profile(
        &self,
        params: crate::app::bsky::actor::get_profile::Parameters,
    ) -> Result<
        crate::app::bsky::actor::get_profile::Output,
        atrium_xrpc::error::Error<crate::app::bsky::actor::get_profile::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.getProfile".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get detailed profile views of multiple actors.
    pub async fn get_profiles(
        &self,
        params: crate::app::bsky::actor::get_profiles::Parameters,
    ) -> Result<
        crate::app::bsky::actor::get_profiles::Output,
        atrium_xrpc::error::Error<crate::app::bsky::actor::get_profiles::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.getProfiles".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of suggested actors, used for discovery.
    pub async fn get_suggestions(
        &self,
        params: crate::app::bsky::actor::get_suggestions::Parameters,
    ) -> Result<
        crate::app::bsky::actor::get_suggestions::Output,
        atrium_xrpc::error::Error<crate::app::bsky::actor::get_suggestions::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.getSuggestions".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Set the private preferences attached to the account.
    pub async fn put_preferences(
        &self,
        input: crate::app::bsky::actor::put_preferences::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::actor::put_preferences::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.actor.putPreferences".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Find actors (profiles) matching search criteria.
    pub async fn search_actors(
        &self,
        params: crate::app::bsky::actor::search_actors::Parameters,
    ) -> Result<
        crate::app::bsky::actor::search_actors::Output,
        atrium_xrpc::error::Error<crate::app::bsky::actor::search_actors::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.searchActors".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Find actor suggestions for a prefix search term.
    pub async fn search_actors_typeahead(
        &self,
        params: crate::app::bsky::actor::search_actors_typeahead::Parameters,
    ) -> Result<
        crate::app::bsky::actor::search_actors_typeahead::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::actor::search_actors_typeahead::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.actor.searchActorsTypeahead".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::feed::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Get information about a feed generator, including policies and offered feed URIs.
    pub async fn describe_feed_generator(
        &self,
    ) -> Result<
        crate::app::bsky::feed::describe_feed_generator::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::describe_feed_generator::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.describeFeedGenerator".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of feeds created by the actor.
    pub async fn get_actor_feeds(
        &self,
        params: crate::app::bsky::feed::get_actor_feeds::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_actor_feeds::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_actor_feeds::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getActorFeeds".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of posts liked by an actor.
    pub async fn get_actor_likes(
        &self,
        params: crate::app::bsky::feed::get_actor_likes::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_actor_likes::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_actor_likes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getActorLikes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a view of an actor's feed.
    pub async fn get_author_feed(
        &self,
        params: crate::app::bsky::feed::get_author_feed::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_author_feed::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_author_feed::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getAuthorFeed".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a hydrated feed from an actor's selected feed generator.
    pub async fn get_feed(
        &self,
        params: crate::app::bsky::feed::get_feed::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_feed::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_feed::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getFeed".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get information about a feed generator.
    pub async fn get_feed_generator(
        &self,
        params: crate::app::bsky::feed::get_feed_generator::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_feed_generator::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_feed_generator::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getFeedGenerator".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get information about a list of feed generators.
    pub async fn get_feed_generators(
        &self,
        params: crate::app::bsky::feed::get_feed_generators::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_feed_generators::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_feed_generators::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getFeedGenerators".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a skeleton of a feed provided by a feed generator.
    pub async fn get_feed_skeleton(
        &self,
        params: crate::app::bsky::feed::get_feed_skeleton::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_feed_skeleton::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_feed_skeleton::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getFeedSkeleton".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get the list of likes.
    pub async fn get_likes(
        &self,
        params: crate::app::bsky::feed::get_likes::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_likes::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_likes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getLikes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a view of a recent posts from actors in a list.
    pub async fn get_list_feed(
        &self,
        params: crate::app::bsky::feed::get_list_feed::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_list_feed::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_list_feed::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getListFeed".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get posts in a thread.
    pub async fn get_post_thread(
        &self,
        params: crate::app::bsky::feed::get_post_thread::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_post_thread::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_post_thread::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getPostThread".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a view of an actor's feed.
    pub async fn get_posts(
        &self,
        params: crate::app::bsky::feed::get_posts::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_posts::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_posts::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getPosts".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of reposts.
    pub async fn get_reposted_by(
        &self,
        params: crate::app::bsky::feed::get_reposted_by::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_reposted_by::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_reposted_by::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getRepostedBy".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of suggested feeds for the viewer.
    pub async fn get_suggested_feeds(
        &self,
        params: crate::app::bsky::feed::get_suggested_feeds::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_suggested_feeds::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_suggested_feeds::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getSuggestedFeeds".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a view of the actor's home timeline.
    pub async fn get_timeline(
        &self,
        params: crate::app::bsky::feed::get_timeline::Parameters,
    ) -> Result<
        crate::app::bsky::feed::get_timeline::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::get_timeline::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.getTimeline".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Find posts matching search criteria.
    pub async fn search_posts(
        &self,
        params: crate::app::bsky::feed::search_posts::Parameters,
    ) -> Result<
        crate::app::bsky::feed::search_posts::Output,
        atrium_xrpc::error::Error<crate::app::bsky::feed::search_posts::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.feed.searchPosts".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::graph::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Get a list of who the actor is blocking.
    pub async fn get_blocks(
        &self,
        params: crate::app::bsky::graph::get_blocks::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_blocks::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_blocks::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getBlocks".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of an actor's followers.
    pub async fn get_followers(
        &self,
        params: crate::app::bsky::graph::get_followers::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_followers::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_followers::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getFollowers".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of who the actor follows.
    pub async fn get_follows(
        &self,
        params: crate::app::bsky::graph::get_follows::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_follows::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_follows::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getFollows".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of actors.
    pub async fn get_list(
        &self,
        params: crate::app::bsky::graph::get_list::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_list::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_list::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getList".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get lists that the actor is blocking.
    pub async fn get_list_blocks(
        &self,
        params: crate::app::bsky::graph::get_list_blocks::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_list_blocks::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_list_blocks::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getListBlocks".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get lists that the actor is muting.
    pub async fn get_list_mutes(
        &self,
        params: crate::app::bsky::graph::get_list_mutes::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_list_mutes::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_list_mutes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getListMutes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of lists that belong to an actor.
    pub async fn get_lists(
        &self,
        params: crate::app::bsky::graph::get_lists::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_lists::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_lists::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getLists".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of who the actor mutes.
    pub async fn get_mutes(
        &self,
        params: crate::app::bsky::graph::get_mutes::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_mutes::Output,
        atrium_xrpc::error::Error<crate::app::bsky::graph::get_mutes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getMutes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get suggested follows related to a given actor.
    pub async fn get_suggested_follows_by_actor(
        &self,
        params: crate::app::bsky::graph::get_suggested_follows_by_actor::Parameters,
    ) -> Result<
        crate::app::bsky::graph::get_suggested_follows_by_actor::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::graph::get_suggested_follows_by_actor::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.graph.getSuggestedFollowsByActor".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Mute an actor by DID or handle.
    pub async fn mute_actor(
        &self,
        input: crate::app::bsky::graph::mute_actor::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::graph::mute_actor::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.graph.muteActor".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Mute a list of actors.
    pub async fn mute_actor_list(
        &self,
        input: crate::app::bsky::graph::mute_actor_list::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::graph::mute_actor_list::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.graph.muteActorList".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Unmute an actor by DID or handle.
    pub async fn unmute_actor(
        &self,
        input: crate::app::bsky::graph::unmute_actor::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::graph::unmute_actor::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.graph.unmuteActor".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Unmute a list of actors.
    pub async fn unmute_actor_list(
        &self,
        input: crate::app::bsky::graph::unmute_actor_list::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::graph::unmute_actor_list::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.graph.unmuteActorList".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::notification::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Get the count of unread notifications.
    pub async fn get_unread_count(
        &self,
        params: crate::app::bsky::notification::get_unread_count::Parameters,
    ) -> Result<
        crate::app::bsky::notification::get_unread_count::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::notification::get_unread_count::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.notification.getUnreadCount".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of notifications.
    pub async fn list_notifications(
        &self,
        params: crate::app::bsky::notification::list_notifications::Parameters,
    ) -> Result<
        crate::app::bsky::notification::list_notifications::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::notification::list_notifications::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.notification.listNotifications".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Register for push notifications with a service.
    pub async fn register_push(
        &self,
        input: crate::app::bsky::notification::register_push::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::notification::register_push::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.notification.registerPush".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Notify server that the user has seen notifications.
    pub async fn update_seen(
        &self,
        input: crate::app::bsky::notification::update_seen::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::app::bsky::notification::update_seen::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "app.bsky.notification.updateSeen".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::unspecced::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///DEPRECATED: will be removed soon. Use a feed generator alternative.
    pub async fn get_popular(
        &self,
        params: crate::app::bsky::unspecced::get_popular::Parameters,
    ) -> Result<
        crate::app::bsky::unspecced::get_popular::Output,
        atrium_xrpc::error::Error<crate::app::bsky::unspecced::get_popular::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.unspecced.getPopular".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///An unspecced view of globally popular feed generators.
    pub async fn get_popular_feed_generators(
        &self,
        params: crate::app::bsky::unspecced::get_popular_feed_generators::Parameters,
    ) -> Result<
        crate::app::bsky::unspecced::get_popular_feed_generators::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::unspecced::get_popular_feed_generators::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.unspecced.getPopularFeedGenerators".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///DEPRECATED: a skeleton of a timeline. Unspecced and will be unavailable soon.
    pub async fn get_timeline_skeleton(
        &self,
        params: crate::app::bsky::unspecced::get_timeline_skeleton::Parameters,
    ) -> Result<
        crate::app::bsky::unspecced::get_timeline_skeleton::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::unspecced::get_timeline_skeleton::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.unspecced.getTimelineSkeleton".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Backend Actors (profile) search, returns only skeleton.
    pub async fn search_actors_skeleton(
        &self,
        params: crate::app::bsky::unspecced::search_actors_skeleton::Parameters,
    ) -> Result<
        crate::app::bsky::unspecced::search_actors_skeleton::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::unspecced::search_actors_skeleton::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.unspecced.searchActorsSkeleton".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Backend Posts search, returns only skeleton
    pub async fn search_posts_skeleton(
        &self,
        params: crate::app::bsky::unspecced::search_posts_skeleton::Parameters,
    ) -> Result<
        crate::app::bsky::unspecced::search_posts_skeleton::Output,
        atrium_xrpc::error::Error<
            crate::app::bsky::unspecced::search_posts_skeleton::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "app.bsky.unspecced.searchPostsSkeleton".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            atproto: com::atproto::Service::new(std::sync::Arc::clone(&xrpc)),
        }
    }
}
impl<T> com::atproto::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            admin: com::atproto::admin::Service::new(std::sync::Arc::clone(&xrpc)),
            identity: com::atproto::identity::Service::new(std::sync::Arc::clone(&xrpc)),
            label: com::atproto::label::Service::new(std::sync::Arc::clone(&xrpc)),
            moderation: com::atproto::moderation::Service::new(
                std::sync::Arc::clone(&xrpc),
            ),
            repo: com::atproto::repo::Service::new(std::sync::Arc::clone(&xrpc)),
            server: com::atproto::server::Service::new(std::sync::Arc::clone(&xrpc)),
            sync: com::atproto::sync::Service::new(std::sync::Arc::clone(&xrpc)),
            temp: com::atproto::temp::Service::new(std::sync::Arc::clone(&xrpc)),
        }
    }
}
impl<T> com::atproto::admin::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Delete a user account as an administrator.
    pub async fn delete_account(
        &self,
        input: crate::com::atproto::admin::delete_account::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::admin::delete_account::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.deleteAccount".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Disable an account from receiving new invite codes, but does not invalidate existing codes.
    pub async fn disable_account_invites(
        &self,
        input: crate::com::atproto::admin::disable_account_invites::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::disable_account_invites::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.disableAccountInvites".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Disable some set of codes and/or all codes associated with a set of users.
    pub async fn disable_invite_codes(
        &self,
        input: crate::com::atproto::admin::disable_invite_codes::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::disable_invite_codes::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.disableInviteCodes".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Take a moderation action on an actor.
    pub async fn emit_moderation_event(
        &self,
        input: crate::com::atproto::admin::emit_moderation_event::Input,
    ) -> Result<
        crate::com::atproto::admin::emit_moderation_event::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::emit_moderation_event::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.emitModerationEvent".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Re-enable an account's ability to receive invite codes.
    pub async fn enable_account_invites(
        &self,
        input: crate::com::atproto::admin::enable_account_invites::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::enable_account_invites::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.enableAccountInvites".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get details about an account.
    pub async fn get_account_info(
        &self,
        params: crate::com::atproto::admin::get_account_info::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_account_info::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::get_account_info::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getAccountInfo".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get an admin view of invite codes.
    pub async fn get_invite_codes(
        &self,
        params: crate::com::atproto::admin::get_invite_codes::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_invite_codes::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::get_invite_codes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getInviteCodes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get details about a moderation event.
    pub async fn get_moderation_event(
        &self,
        params: crate::com::atproto::admin::get_moderation_event::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_moderation_event::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::get_moderation_event::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getModerationEvent".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get details about a record.
    pub async fn get_record(
        &self,
        params: crate::com::atproto::admin::get_record::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_record::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::get_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getRecord".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get details about a repository.
    pub async fn get_repo(
        &self,
        params: crate::com::atproto::admin::get_repo::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_repo::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::get_repo::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getRepo".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get the service-specific admin status of a subject (account, record, or blob).
    pub async fn get_subject_status(
        &self,
        params: crate::com::atproto::admin::get_subject_status::Parameters,
    ) -> Result<
        crate::com::atproto::admin::get_subject_status::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::get_subject_status::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.getSubjectStatus".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///List moderation events related to a subject.
    pub async fn query_moderation_events(
        &self,
        params: crate::com::atproto::admin::query_moderation_events::Parameters,
    ) -> Result<
        crate::com::atproto::admin::query_moderation_events::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::query_moderation_events::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.queryModerationEvents".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///View moderation statuses of subjects (record or repo).
    pub async fn query_moderation_statuses(
        &self,
        params: crate::com::atproto::admin::query_moderation_statuses::Parameters,
    ) -> Result<
        crate::com::atproto::admin::query_moderation_statuses::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::query_moderation_statuses::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.queryModerationStatuses".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Find repositories based on a search term.
    pub async fn search_repos(
        &self,
        params: crate::com::atproto::admin::search_repos::Parameters,
    ) -> Result<
        crate::com::atproto::admin::search_repos::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::search_repos::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.admin.searchRepos".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Send email to a user's account email address.
    pub async fn send_email(
        &self,
        input: crate::com::atproto::admin::send_email::Input,
    ) -> Result<
        crate::com::atproto::admin::send_email::Output,
        atrium_xrpc::error::Error<crate::com::atproto::admin::send_email::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.sendEmail".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Administrative action to update an account's email.
    pub async fn update_account_email(
        &self,
        input: crate::com::atproto::admin::update_account_email::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::update_account_email::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.updateAccountEmail".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Administrative action to update an account's handle.
    pub async fn update_account_handle(
        &self,
        input: crate::com::atproto::admin::update_account_handle::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::update_account_handle::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.updateAccountHandle".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Update the service-specific admin status of a subject (account, record, or blob).
    pub async fn update_subject_status(
        &self,
        input: crate::com::atproto::admin::update_subject_status::Input,
    ) -> Result<
        crate::com::atproto::admin::update_subject_status::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::admin::update_subject_status::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.admin.updateSubjectStatus".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::identity::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Provides the DID of a repo.
    pub async fn resolve_handle(
        &self,
        params: crate::com::atproto::identity::resolve_handle::Parameters,
    ) -> Result<
        crate::com::atproto::identity::resolve_handle::Output,
        atrium_xrpc::error::Error<crate::com::atproto::identity::resolve_handle::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.identity.resolveHandle".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Updates the handle of the account.
    pub async fn update_handle(
        &self,
        input: crate::com::atproto::identity::update_handle::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::identity::update_handle::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.identity.updateHandle".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::label::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Find labels relevant to the provided URI patterns.
    pub async fn query_labels(
        &self,
        params: crate::com::atproto::label::query_labels::Parameters,
    ) -> Result<
        crate::com::atproto::label::query_labels::Output,
        atrium_xrpc::error::Error<crate::com::atproto::label::query_labels::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.label.queryLabels".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::moderation::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Report a repo or a record.
    pub async fn create_report(
        &self,
        input: crate::com::atproto::moderation::create_report::Input,
    ) -> Result<
        crate::com::atproto::moderation::create_report::Output,
        atrium_xrpc::error::Error<crate::com::atproto::moderation::create_report::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.moderation.createReport".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::repo::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Apply a batch transaction of creates, updates, and deletes.
    pub async fn apply_writes(
        &self,
        input: crate::com::atproto::repo::apply_writes::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::repo::apply_writes::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.repo.applyWrites".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create a new record.
    pub async fn create_record(
        &self,
        input: crate::com::atproto::repo::create_record::Input,
    ) -> Result<
        crate::com::atproto::repo::create_record::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::create_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.repo.createRecord".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Delete a record, or ensure it doesn't exist.
    pub async fn delete_record(
        &self,
        input: crate::com::atproto::repo::delete_record::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::repo::delete_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.repo.deleteRecord".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get information about the repo, including the list of collections.
    pub async fn describe_repo(
        &self,
        params: crate::com::atproto::repo::describe_repo::Parameters,
    ) -> Result<
        crate::com::atproto::repo::describe_repo::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::describe_repo::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.repo.describeRepo".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a record.
    pub async fn get_record(
        &self,
        params: crate::com::atproto::repo::get_record::Parameters,
    ) -> Result<
        crate::com::atproto::repo::get_record::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::get_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.repo.getRecord".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///List a range of records in a collection.
    pub async fn list_records(
        &self,
        params: crate::com::atproto::repo::list_records::Parameters,
    ) -> Result<
        crate::com::atproto::repo::list_records::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::list_records::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.repo.listRecords".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Write a record, creating or updating it as needed.
    pub async fn put_record(
        &self,
        input: crate::com::atproto::repo::put_record::Input,
    ) -> Result<
        crate::com::atproto::repo::put_record::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::put_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.repo.putRecord".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Upload a new blob to be added to repo in a later request.
    pub async fn upload_blob(
        &self,
        input: Vec<u8>,
    ) -> Result<
        crate::com::atproto::repo::upload_blob::Output,
        atrium_xrpc::error::Error<crate::com::atproto::repo::upload_blob::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                Vec<u8>,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.repo.uploadBlob".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Bytes(input)),
                    encoding: Some(String::from("*/*")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::server::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Confirm an email using a token from com.atproto.server.requestEmailConfirmation.
    pub async fn confirm_email(
        &self,
        input: crate::com::atproto::server::confirm_email::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::confirm_email::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.confirmEmail".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create an account.
    pub async fn create_account(
        &self,
        input: crate::com::atproto::server::create_account::Input,
    ) -> Result<
        crate::com::atproto::server::create_account::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::create_account::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.createAccount".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create an App Password.
    pub async fn create_app_password(
        &self,
        input: crate::com::atproto::server::create_app_password::Input,
    ) -> Result<
        crate::com::atproto::server::create_app_password::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::server::create_app_password::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.createAppPassword".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create an invite code.
    pub async fn create_invite_code(
        &self,
        input: crate::com::atproto::server::create_invite_code::Input,
    ) -> Result<
        crate::com::atproto::server::create_invite_code::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::create_invite_code::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.createInviteCode".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create invite codes.
    pub async fn create_invite_codes(
        &self,
        input: crate::com::atproto::server::create_invite_codes::Input,
    ) -> Result<
        crate::com::atproto::server::create_invite_codes::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::server::create_invite_codes::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.createInviteCodes".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Create an authentication session.
    pub async fn create_session(
        &self,
        input: crate::com::atproto::server::create_session::Input,
    ) -> Result<
        crate::com::atproto::server::create_session::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::create_session::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.createSession".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Delete an actor's account with a token and password.
    pub async fn delete_account(
        &self,
        input: crate::com::atproto::server::delete_account::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::delete_account::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.deleteAccount".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Delete the current session.
    pub async fn delete_session(
        &self,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::delete_session::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.deleteSession".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get a document describing the service's accounts configuration.
    pub async fn describe_server(
        &self,
    ) -> Result<
        crate::com::atproto::server::describe_server::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::describe_server::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.server.describeServer".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get all invite codes for a given account.
    pub async fn get_account_invite_codes(
        &self,
        params: crate::com::atproto::server::get_account_invite_codes::Parameters,
    ) -> Result<
        crate::com::atproto::server::get_account_invite_codes::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::server::get_account_invite_codes::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.server.getAccountInviteCodes".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get information about the current session.
    pub async fn get_session(
        &self,
    ) -> Result<
        crate::com::atproto::server::get_session::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::get_session::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.server.getSession".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///List all App Passwords.
    pub async fn list_app_passwords(
        &self,
    ) -> Result<
        crate::com::atproto::server::list_app_passwords::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::list_app_passwords::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.server.listAppPasswords".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Refresh an authentication session.
    pub async fn refresh_session(
        &self,
    ) -> Result<
        crate::com::atproto::server::refresh_session::Output,
        atrium_xrpc::error::Error<crate::com::atproto::server::refresh_session::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.refreshSession".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Initiate a user account deletion via email.
    pub async fn request_account_delete(
        &self,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::server::request_account_delete::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.requestAccountDelete".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Request an email with a code to confirm ownership of email.
    pub async fn request_email_confirmation(
        &self,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::server::request_email_confirmation::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.requestEmailConfirmation".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Request a token in order to update email.
    pub async fn request_email_update(
        &self,
    ) -> Result<
        crate::com::atproto::server::request_email_update::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::server::request_email_update::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.requestEmailUpdate".into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Initiate a user account password reset via email.
    pub async fn request_password_reset(
        &self,
        input: crate::com::atproto::server::request_password_reset::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::server::request_password_reset::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.requestPasswordReset".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Reserve a repo signing key for account creation.
    pub async fn reserve_signing_key(
        &self,
        input: crate::com::atproto::server::reserve_signing_key::Input,
    ) -> Result<
        crate::com::atproto::server::reserve_signing_key::Output,
        atrium_xrpc::error::Error<
            crate::com::atproto::server::reserve_signing_key::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.reserveSigningKey".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Reset a user account password using a token.
    pub async fn reset_password(
        &self,
        input: crate::com::atproto::server::reset_password::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::reset_password::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.resetPassword".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Revoke an App Password by name.
    pub async fn revoke_app_password(
        &self,
        input: crate::com::atproto::server::revoke_app_password::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<
            crate::com::atproto::server::revoke_app_password::Error,
        >,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.revokeAppPassword".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Update an account's email.
    pub async fn update_email(
        &self,
        input: crate::com::atproto::server::update_email::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::server::update_email::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.server.updateEmail".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::sync::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Get a blob associated with a given repo.
    pub async fn get_blob(
        &self,
        params: crate::com::atproto::sync::get_blob::Parameters,
    ) -> Result<
        Vec<u8>,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_blob::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getBlob".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get blocks from a given repo.
    pub async fn get_blocks(
        &self,
        params: crate::com::atproto::sync::get_blocks::Parameters,
    ) -> Result<
        Vec<u8>,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_blocks::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getBlocks".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///DEPRECATED - please use com.atproto.sync.getRepo instead
    pub async fn get_checkout(
        &self,
        params: crate::com::atproto::sync::get_checkout::Parameters,
    ) -> Result<
        Vec<u8>,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_checkout::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getCheckout".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///DEPRECATED - please use com.atproto.sync.getLatestCommit instead
    pub async fn get_head(
        &self,
        params: crate::com::atproto::sync::get_head::Parameters,
    ) -> Result<
        crate::com::atproto::sync::get_head::Output,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_head::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getHead".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get the current commit CID & revision of the repo.
    pub async fn get_latest_commit(
        &self,
        params: crate::com::atproto::sync::get_latest_commit::Parameters,
    ) -> Result<
        crate::com::atproto::sync::get_latest_commit::Output,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_latest_commit::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getLatestCommit".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Get blocks needed for existence or non-existence of record.
    pub async fn get_record(
        &self,
        params: crate::com::atproto::sync::get_record::Parameters,
    ) -> Result<
        Vec<u8>,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_record::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getRecord".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Gets the DID's repo, optionally catching up from a specific revision.
    pub async fn get_repo(
        &self,
        params: crate::com::atproto::sync::get_repo::Parameters,
    ) -> Result<
        Vec<u8>,
        atrium_xrpc::error::Error<crate::com::atproto::sync::get_repo::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.getRepo".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///List blob CIDs since some revision.
    pub async fn list_blobs(
        &self,
        params: crate::com::atproto::sync::list_blobs::Parameters,
    ) -> Result<
        crate::com::atproto::sync::list_blobs::Output,
        atrium_xrpc::error::Error<crate::com::atproto::sync::list_blobs::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.listBlobs".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///List DIDs and root CIDs of hosted repos.
    pub async fn list_repos(
        &self,
        params: crate::com::atproto::sync::list_repos::Parameters,
    ) -> Result<
        crate::com::atproto::sync::list_repos::Output,
        atrium_xrpc::error::Error<crate::com::atproto::sync::list_repos::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.sync.listRepos".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Notify a crawling service of a recent update; often when a long break between updates causes the connection with the crawling service to break.
    pub async fn notify_of_update(
        &self,
        input: crate::com::atproto::sync::notify_of_update::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::sync::notify_of_update::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.sync.notifyOfUpdate".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Request a service to persistently crawl hosted repos.
    pub async fn request_crawl(
        &self,
        input: crate::com::atproto::sync::request_crawl::Input,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::sync::request_crawl::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.sync.requestCrawl".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::temp::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self { xrpc }
    }
    ///Fetch all labels from a labeler created after a certain date.
    pub async fn fetch_labels(
        &self,
        params: crate::com::atproto::temp::fetch_labels::Parameters,
    ) -> Result<
        crate::com::atproto::temp::fetch_labels::Output,
        atrium_xrpc::error::Error<crate::com::atproto::temp::fetch_labels::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    path: "com.atproto.temp.fetchLabels".into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Gets the did's repo, optionally catching up from a specific revision.
    pub async fn import_repo(
        &self,
        input: Vec<u8>,
    ) -> Result<
        Vec<u8>,
        atrium_xrpc::error::Error<crate::com::atproto::temp::import_repo::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                Vec<u8>,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.temp.importRepo".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Bytes(input)),
                    encoding: Some(String::from("application/vnd.ipld.car")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Gets the did's repo, optionally catching up from a specific revision.
    pub async fn push_blob(
        &self,
        input: Vec<u8>,
    ) -> Result<
        (),
        atrium_xrpc::error::Error<crate::com::atproto::temp::push_blob::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                Vec<u8>,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.temp.pushBlob".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Bytes(input)),
                    encoding: Some(String::from("*/*")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
    ///Transfer an account.
    pub async fn transfer_account(
        &self,
        input: crate::com::atproto::temp::transfer_account::Input,
    ) -> Result<
        crate::com::atproto::temp::transfer_account::Output,
        atrium_xrpc::error::Error<crate::com::atproto::temp::transfer_account::Error>,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    path: "com.atproto.temp.transferAccount".into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::error::Error::UnexpectedResponseType),
        }
    }
}
