use crate::fs::find_dirs;
use crate::schema::find_ref_unions;
use crate::token_stream::{client, modules, ref_unions, refs_enum, user_type};
use atrium_lex::lexicon::LexUserType;
use atrium_lex::LexiconDoc;
use heck::ToSnakeCase;
use itertools::Itertools;
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::{HashMap, HashSet};
use std::error::Error;
use std::fs::{create_dir_all, read_dir, File};
use std::io::Write;
use std::path::{Path, PathBuf};

const HEADER: &str = "// This file is generated by atrium-codegen. DO NOT EDIT.";

pub(crate) fn generate_schemas(
    schema: &LexiconDoc,
    outdir: &Path,
) -> Result<Vec<PathBuf>, Box<dyn Error>> {
    let mut results = Vec::new();
    let mut paths = schema.id.split('.').collect::<Vec<_>>();
    if let Some(basename) = paths.pop() {
        let mut tokens = Vec::new();
        let mut names = Vec::new();
        // main def
        for (name, def) in &schema.defs {
            if name == "main" {
                tokens.push(user_type(def, basename, true)?);
            } else {
                names.push(name);
            }
        }
        // other defs
        for &name in names.iter().sorted() {
            tokens.push(user_type(&schema.defs[name], name, false)?);
        }
        // ref unions
        tokens.push(ref_unions(&schema.id, &find_ref_unions(&schema.defs))?);

        let documentation = {
            let doc = format!("Definitions for the `{}` namespace.", schema.id);
            let description = if let Some(description) = &schema.description {
                quote!(#![doc = #description])
            } else {
                quote!()
            };
            quote! {
                #![doc = #doc]
                #description
            }
        };
        let content = quote! {
            #documentation
            #(#tokens)*
        };
        let dir = outdir.join(paths.join("/"));
        create_dir_all(&dir)?;
        let mut filename = PathBuf::from(basename.to_snake_case());
        filename.set_extension("rs");
        let path = dir.join(filename);
        write_to_file(File::create(&path)?, content)?;
        results.push(path);
    }
    Ok(results)
}

pub(crate) fn generate_records(
    outdir: &Path,
    schemas: &[LexiconDoc],
) -> Result<PathBuf, Box<dyn Error>> {
    let records = schemas
        .iter()
        .filter_map(|schema| {
            if let Some(LexUserType::Record(_)) = schema.defs.get("main") {
                Some(schema.id.clone())
            } else {
                None
            }
        })
        .sorted()
        .collect_vec();
    let tokens = refs_enum(&records, "Record", None)?;
    let content = quote! {
        #![doc = "A collection of ATP repository record types."]
        #tokens
    };
    let path = outdir.join("records.rs");
    write_to_file(File::create(&path)?, content)?;
    Ok(path)
}

pub(crate) fn generate_client(
    outdir: &Path,
    schemas: &[LexiconDoc],
) -> Result<PathBuf, Box<dyn Error>> {
    let mut schema_map = HashMap::new();
    let mut tree = HashMap::new();
    for schema in schemas {
        if let Some(def) = schema.defs.get("main") {
            if matches!(
                def,
                LexUserType::XrpcQuery(_) | LexUserType::XrpcProcedure(_)
            ) {
                schema_map.insert(schema.id.clone(), def);
                let mut parts = schema.id.split('.').collect_vec();
                let mut is_leaf = true;
                while let Some(part) = parts.pop() {
                    let key = parts.join(".");
                    tree.entry(key)
                        .or_insert_with(HashSet::new)
                        .insert((part, is_leaf));
                    is_leaf = false;
                }
            }
        }
    }
    let tokens = client(&tree, &schema_map)?;
    let content = quote! {
        #![doc = r#"An ATP "Client". Implements all HTTP APIs of XRPC."#]
        #tokens
    };
    let path = outdir.join("client.rs");
    write_to_file(File::create(&path)?, content)?;
    Ok(path)
}

pub(crate) fn generate_modules(outdir: &Path) -> Result<Vec<PathBuf>, Box<dyn Error>> {
    let paths = find_dirs(outdir)?;
    let mut files = Vec::with_capacity(paths.len());
    // generate ".rs" files names
    for path in &paths {
        if path.as_ref() == outdir {
            files.push(outdir.join("lib.rs"));
        } else {
            let mut p = path.as_ref().to_path_buf();
            p.set_extension("rs");
            files.push(p);
        }
    }
    // write "mod" statements
    for (path, filepath) in paths.iter().zip(&files) {
        let names = read_dir(path)?
            .filter_map(Result::ok)
            .filter(|entry| entry.path().is_file())
            .filter_map(|entry| {
                entry
                    .path()
                    .file_stem()
                    .map(|s| s.to_string_lossy().into_owned())
            })
            .sorted()
            .collect_vec();
        let modules = modules(&names)?;
        let documentation = if path.as_ref() == outdir {
            quote!(#![doc = include_str!("../README.md")])
        } else {
            quote!()
        };
        let content = quote! {
            #documentation
            #modules
        };
        write_to_file(File::create(filepath)?, content)?;
    }
    Ok(files)
}

fn write_to_file(mut file: impl Write, content: TokenStream) -> Result<(), std::io::Error> {
    writeln!(file, "{HEADER}")?;
    writeln!(file, "{content}")?;
    Ok(())
}
